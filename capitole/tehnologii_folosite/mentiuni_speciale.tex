\section{Mențiuni speciale}

	Fără părinți nu ajungeai cea mai bună variantă a ta.
	Eu n-aș fi putut să obțin tot ceea ce mi-am propus, în timpul alocat, dacă n-ar fi existat aceste utilitare.

	Așa cum pentru Laravel există consola Artisan, pentru gestionarea proiectului am folosit PhpStorm, un mediu de dezvoltare integrat oferit de cei de la JetBrains.

	Pentru a gestiona cunoștințele dobândite despre acest proiect în particular, mai ales ce pași trebuiesc respectați în momentul în care încarc pe server-ul partajat ultima variantă a codului, fără să uit ceva și ulterior codul pentru a face asta automat, am folosit o tablă Kanban.

	Pentru a testa, am folosit Heroku, iar pentru a asigura salvarea eficientă a datelor am folosit AWS („Amazon Web Services”).

	Pentru a include diverse mici proiecte, scrise de alți oameni puși în aceeași situație, am folosit Composer împreună cu npm.

	Iar pentru această lucrare de licență, pe care o citiți în acest moment (vorbind de spargerea celui de-al patrulea zid, nu?), am folosit Sublime Text 3 și \LaTeX.

	\subsection{Google Analytics}

	Pentru a înțelege traficul venind, am ales să folosesc analizatorul gratuit (cu elemente premium) oferit de Google.
	Oferă o sumedenie de detalii despre cum interacționează utilizatorul cu aplicația, de la cât timp petrece un client web pe o anumită pagină, la cele mai des folosite butoane sau cele mai des folosite drumuri (legături între mai multe pagini). \cite{google_analytics}
	De asemenea, poți vedea ce a declanșat o eroare, ceea ce pentru un dezvoltator ajută la identificarea și rezolvarea problemelor din momentul în care apar, nu după ce primești un apel furios de la unul dintre fondatorii companiei.

	Am descoperit, urmărind traficul pentru o săptămână, că punctul sensibil și cel mai des folosit era în momentul în care se căuta o cerere de despăgubire.
	De cele mai multe ori, se știa deja numărul cererii, trebuia doar să se acceseze panoul de căutare și să se introducă numărul în căsuță.

	Astfel am realizat o mică modificare a panoului de navigare principal.
	Se regăsește mulțumită structurii Laravel de organizare a unei aplicații, pe fiecare pagină.
	Modificarea constă în includerea unui câmp completabil rapid.
	După ce s-a completat și utilizatorul a validat codul, se apelează aceeași funcție de căutare în spate, precum accesare panoului de căutarea și introducerea sa în căsuță.

	S-a mai observat durata lungă petrecută de clienți în momentul introducerii datelor cererii de despăgubire.
	Din fericire, Laravel a fost conceput cu un sistem avansat de „uitare” a sesiunii, pentru a preveni abuzurile.
	Dar acesta interfera cu durata lungă în care clienții își completau probabil informațiile și apărea des o eroare a expirării sesiunii.
	Am reușit să previn această problemă apelând constant, prin jQuery, un punct al aplicației ce avea singurul rol de a actualiza sesiunea pentru Laravel, declarând-o activă.
	Utilizator putea în final să stea liniștit și să completeze toate datele, indiferent de cât i-ar fi luat.

	\subsection{Găzduire partajată}

		Găzduirea partajată se folosește pentru a pune un web server conectat la internet valabil pentru mai multe persoane.
		Partajându-se mai multor clienți, se amortizează costul îngrijirii și astfel prețurile sunt reduse.

		Am ales pentru Fandu soluția oferită de xServers\cite{xservers} pentru că nu era doar convenabilă și aveam încredere în ei, pentru că mai găzduisem înainte propria mea pagină, ci pentru certificatele ce asigură calitatea și securitatea.

		Aplicația se mișcă rapid, totul fiind salvat pe servere virtuale cu SSD-uri („Solid State Drive”).

		Un mare avantaj, dar în același timp și dezavantaj este oprirea comenzii de interpretare și executare a codului PHP, \verb|eval|.
		Din păcate, este problematic pentru consola Artisan, pentru că nu poate să aplice în momentul actualizării bazei de date tot codul de migrare.

		Soluția, la care s-a ajuns drept compromis în urma dezbaterilor cu departamentul tehnic, ce migrează codul și baza de date a server-ului, este:
		\begin{enumerate}
			\item
				Se salvează toate datele existente, folosind utilitarul oferit de xServers.
			\item
				Se introduce un fișier nou în directorul aplicației la:
				\begin{verbatim}
					storage/framework/down
				\end{verbatim}
				Se închide astfel accesul la server cât timp se migrează baza de date și conținutul aplicației în sine.
			\item
				Se află codul necesar migrării bazei de date prin comanda:
				\begin{verbatim}
					php artisan migrate --pretend -vvv
				\end{verbatim}
				Ce reiese va fi cod SQL ce va fi copiat cu ușurință în phpMyAdmin-ul de pe server.
			\item
				După ce s-a migrat cu succes baza de date, se copiază următoarele foldere:
					\begin{itemize}
						\item \verb|app| - tot codul important al aplicației.
						\item \verb|bootstrap| - sistemul de încărcare a platformei Laravel.
						\item \verb|config| - setările implicite Laravel, în lipsa valorilor în fișierul mediului curent (\verb|.env|).
						\item \verb|database| - migrările bazei de date
						\item \verb|public| - pentru că folosim „Laravel Elixir”, ce se ocupă de gestiunea variantelor codului JavaScript și CSS, se vor copia și în calea publică \verb|public_html|, pentru că acestea vor fi servite clienților și trebuie să poată să fie accesibile.
						\item \verb|resources| - directivele Blade, codul JavaScript și SASS.
						\item \verb|routes| - rutele ce determină Controller-ul apelat.
						\item \verb|storage| - doar structura, pentru că va conține fișierele temporare traduse din Blade în PHP.
						\item \verb|tests| - se poate sări, pentru că nu afectează rezultatul final.
						\item \verb|vendor| - dacă s-a modificat \verb|composer.json|, adăugând sau modificând sau ștergând pachete.
					\end{itemize}
			\item
				Se va șterge fișierul nou creat:
				\begin{verbatim}
					storage/framework/down
				\end{verbatim}
				și astfel migrația va fi completă.
		\end{enumerate}

		În cazul unor migrări minore, ce nu implică baza de date, se pot suprascrie direct fișierele modificate în cadrul aplicației.
		PhpStorm ajută aici prin opțiunea de a încărca prin FTP (encriptat) fișierele modificate.

		\textbf{\underline{Observație:}} Se copiază directorul \verb|public| de două ori, când se fac modificări la stil sau la codul JavaScript: o dată în cadrul directorului ce conține întregul proiect Laravel și o dată în directorul \verb|public_html|.

		„Laravel Elixir” funcționează bazându-se pe un fișier JSON, ce spune ce versiune de stil și cod să folosească, aflat la:
		\begin{verbatim}
			/public/build/rev-manifest.json
		\end{verbatim}

		Această cale nu este valabilă clienților, pentru că aplicația nu se află în directorul public.
		S-au făcut deci mici modificări asupra fișierului \verb|index.php|, aflat tot în directorul public, pentru a arăta calea corectă.

		Trebuie să se copieze, în concluzie, codul și stilul și în acest director.

	\subsection{PhpStorm IDE}

		Chiar dacă Laravel a fost gândit cu cât mai puține referințe, cu cât mai mult cod ajutător pentru dezvoltator și o grămadă de resurse valabile pe diverse site-uri, nu se poate compara cu un mediu de dezvoltare avansat, ce se ocupă de fișierele dependente, regulile de scriere și formatare a codului.

		PhpStorm este un mediu de dezvoltare comercial, oferit de JetBrains. Suportă completarea avansată a codului PHP 5.6 (și mai nou 7.0), dar și analiza sintactică, prevenirea erorilor.
		Suportă oficial și sistemul relațional de bază de date MySQL.
		Chiar și directivele Blade sunt înțelese de analizatorul sintactic.
		Stilul și codul scris în JavaScript, cunoștințele despre cum poți să rescrii mult mai ușor codul PHP.
		Integrarea cu modul de depanare „XDebug” îl ajută să ajungă în fața multor simple editoare de text.
		Pentru mine, este cel mai de nădejde prieten în bătălia cu codul dezorganizat și inabordabil.

		Pentru a profita din plin de cunoștințele sintactice acestui mediu de dezvoltare, un pachet des întâlnit în PhpStorm când se construiește o aplicație folosind platforma Laravel este: \\
		„Laravel PhpStorm IDE Helper” (\verb|barryvdh/laravel-ide-helper|)

		Mulțumită „Eloquent ORM”, de cele mai multe ori PhpStorm nu poate înțelege de ce a fost apelată o metodă ce nu există - pentru că se va interpreta codul scris în metoda magică \verb|__callStatic|, ce va traduce numele metodei statice într-un text, iar apoi într-o clasă ce va construi o cerere SQL.
		Dar aici intervine „phpDoc”, sistemul preferat de adnotare a funcțiilor, metodelor și variabilelor PHP.
		Pachetul astfel introduce trei funcții ce pot fi apelate de dezvoltator prin intermediul consolei:
			\begin{itemize}
				\item
				\verb|php artisan ide-helper:generate| - generare cod „phpDoc” pentru fațade.
				\item
				\verb|php artisan ide-helper:models| - generare cod „phpDoc” pentru modele.
				\item
				\verb|php artisan ide-helper:meta| - generare cod „phpDoc” pentru structura aplicației.
			\end{itemize}

		De asemenea, se integrează cu sistemul de gestiune a versiunii codului.
		Poate să și încarce automat modificările făcute pe server-ul de producție, folosind protocolul FTP (encriptat, desigur).

		Asigură deci rapiditatea și fluența necesară reparării unor probleme critice și a dezvoltării codului concis, după ghidul dorit de stil.
	\subsection{Heroku}

		N-ar trebui niciodată să scrii cod direct pe mediul de producție.
		Dacă ceva nu merge de prima oară, ai clienți și operatori nemulțumiți.
		Dar poate că nu ai testat destul pe mediul tău local schimbările făcute.
		Nu ai avea de unde să-ți dai seama de toate scenariile posibile.

		Pentru a minimiza impactul unei migrări de asemenea proporții, se recomandă un mediu de testare.
		Heroku este o platformă distribuită ce oferă platforma sa ca un serviciu („PaaS”).
		Oferă servicii pentru mai multe limbaje de programare, printre care și PHP.

		Un mare avantaj al platformei Heroku nu este doar modelul gratuit (până la un punct) de implementare.
		Este implementarea ultimelor modificări prin intermediul proiectului aflat în sistemul de gestiune a codului.
		Preluând ultimele modificări, se pot verifica ultimele modificări aduse codului înainte de a fi urcate pe serverul de producție.

		Oferind și acces în cadrul aplicației la consola Artisan, se pot verifica mai multe sisteme deodată, inclusiv testele automate.
		Testele automate pot fi rulate înainte de a se schimba versiunea activă a mediului de testare pe ultima versiune, pentru a se asigura că nu s-a stricat nimic critic în aplicație.

		Toate aceste motive fac din Heroku mediul meu de testare favorit, ce și-a văzut folosința în cadrul acestui proiect de gestionare a cererilor de despăgubire.
		Mulțumită ușurinței de a schimba variabilele de mediu, am putut să testez de fiecare dată când modificam codul sursă al aplicației schimbările.
		Folosesc în momentul actual o bază de date de test, inclusă gratuit în pachet.

		Doresc să mai investesc timp și să înțeleg mai bine platforma de teste automate, pentru a mă asigura că majoritatea funcționalității existente, la o schimbare, va continua să funcționeze.

	\subsection{Amazon Web Services}

		Inițial, tot proiectul ar fi fost într-o platformă distribuită.
		Dar problema datelor tot rămânea.
		Trebuia să asigur existența și valabilitatea lor pentru o perioadă de minim doi ani.
		Pentru asta, îmi trebuia un sistem distribuit de salvare a datelor.

		Inițial, mă gândeam să aleg soluția oferită de Azure, pentru că mai interacționasem cu ei.
		Dar după ce am mai prospectat piața, am ajuns la concluzia că ar fi mult mai benefic din punctul de vedere al costului întreținerii și a numărului mare de date să aleg „Amazon Web Services” --- S3.

		\subsubsection{Integrarea cu Laravel}

		Integrarea cu Laravel s-a făcut aproape instantaneu, mulțumită fișierului:
		\begin{verbatim}
		config/filesystems.php
		\end{verbatim}
		ce se ocupă cu gestionarea fișierelor aplicației.

		Tot ce a trebuit să se modifice a fost valoarea implicită pentru „cloud” și să se introducă în fișierul de mediu cheia (publică și secretă), precum și regiunea server-ului S3 oferit de AWS.

		Inițial gândisem un sistem de construire a unei imagini cu o rezoluție mult mai mică și a unei imagini normale ca dimensiuni, pentru a păstra cât mai mică dimensiunea imaginilor transferate.

		După o scurtă perioadă de dezvoltare, după ce s-a ajuns la o variantă finală a algoritmului, descoperisem că până la urmă, problema era constrângerea de \verb|5000| de acțiuni de a pune în sistemul de date.
		Optimizasem prematur o problemă inexistentă.
		Astfel am renunțat la construirea imaginii cu rezoluție mult mai mică și nu mai modific imaginea normală.
		Cu această modificare a crescut imens și numărul de tranzacții posibile de server-ul găzduit, pentru că nu mai trebuia să modifice fiecare imagine în parte.

		Dar eram limitați și de numărul de „GET”-uri (i.e: afișarea unei poze de către un client web).
		Am setat ca fiecare obiect încărcat să fie agresiv salvat în memoria clientului web.
		Atunci când se redeschide cererea de despăgubire, se află deja salvat în „cache” și nu numai că nu mai face o cerere sistemului de date, dar se și încarcă instantaneu, ca prin magie.

		O problemă ușor rezolvabilă este ștergerea datelor vechi.
		Am propus și încă aștept un răspuns din partea firmei ca atunci când o cerere de despăgubire nu va mai fi valabilă, să poată să fie salvate pe calculatorul unei persoane autorizate din firmă datele încărcate de client și șterse din sistemul distribuit.

	\subsection{NPM și Composer}
		\subsubsection{integrarea cu laravel - laravel elixir}
		\subsubsection{ce asigura un up-to-date css / js file cu versioning}
		\subsubsection{agregarea css / scss / js -> webpack (minifier) -> versioning ->}
	\subsection{LaTeX și Sublime Text}
		structura licentei
		legatura cu sublime text
